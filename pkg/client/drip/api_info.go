/*
Drip Backend

Drip backend service.

API version: 1.0.0
Contact: dcafmocha@protonmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package drip

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


type InfoApi interface {

	/*
	PositionsGet Get User Positions

	Get all user positions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPositionsGetRequest
	*/
	PositionsGet(ctx context.Context) ApiPositionsGetRequest

	// PositionsGetExecute executes the request
	//  @return []ListPositionsInner
	PositionsGetExecute(r ApiPositionsGetRequest) ([]ListPositionsInner, *http.Response, error)

	/*
	ProtoconfigsGet Get Proto Configs

	Get all proto configs with filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProtoconfigsGetRequest
	*/
	ProtoconfigsGet(ctx context.Context) ApiProtoconfigsGetRequest

	// ProtoconfigsGetExecute executes the request
	//  @return []ListProtoConfigsInner
	ProtoconfigsGetExecute(r ApiProtoconfigsGetRequest) ([]ListProtoConfigsInner, *http.Response, error)

	/*
	RootGet Health Check

	Ping api.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRootGetRequest
	*/
	RootGet(ctx context.Context) ApiRootGetRequest

	// RootGetExecute executes the request
	//  @return PingResponse
	RootGetExecute(r ApiRootGetRequest) (*PingResponse, *http.Response, error)

	/*
	SwaggerJsonGet Swagger spec

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSwaggerJsonGetRequest
	*/
	SwaggerJsonGet(ctx context.Context) ApiSwaggerJsonGetRequest

	// SwaggerJsonGetExecute executes the request
	//  @return map[string]interface{}
	SwaggerJsonGetExecute(r ApiSwaggerJsonGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	SwapConfigsGet Get Token Swaps Configs

	Get token swap configs fro triggerDCA.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSwapConfigsGetRequest
	*/
	SwapConfigsGet(ctx context.Context) ApiSwapConfigsGetRequest

	// SwapConfigsGetExecute executes the request
	//  @return []ListSwapConfigsInner
	SwapConfigsGetExecute(r ApiSwapConfigsGetRequest) ([]ListSwapConfigsInner, *http.Response, error)

	/*
	SwapsGet Get Token Swaps

	Get token swaps with filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSwapsGetRequest
	*/
	SwapsGet(ctx context.Context) ApiSwapsGetRequest

	// SwapsGetExecute executes the request
	//  @return []ListTokenSwapsInner
	SwapsGetExecute(r ApiSwapsGetRequest) ([]ListTokenSwapsInner, *http.Response, error)

	/*
	TokenpairsGet Get Token Pairs

	Get token pairs with filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTokenpairsGetRequest
	*/
	TokenpairsGet(ctx context.Context) ApiTokenpairsGetRequest

	// TokenpairsGetExecute executes the request
	//  @return []ListTokenPairsInner
	TokenpairsGetExecute(r ApiTokenpairsGetRequest) ([]ListTokenPairsInner, *http.Response, error)

	/*
	TokensGet Get Tokens

	Get tokens with filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTokensGetRequest
	*/
	TokensGet(ctx context.Context) ApiTokensGetRequest

	// TokensGetExecute executes the request
	//  @return []ListTokensInner
	TokensGetExecute(r ApiTokensGetRequest) ([]ListTokensInner, *http.Response, error)

	/*
	VaultperiodsGet Get Vault Periods

	Get vault periods with pagination and filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVaultperiodsGetRequest
	*/
	VaultperiodsGet(ctx context.Context) ApiVaultperiodsGetRequest

	// VaultperiodsGetExecute executes the request
	//  @return []ListVaultPeriodsInner
	VaultperiodsGetExecute(r ApiVaultperiodsGetRequest) ([]ListVaultPeriodsInner, *http.Response, error)

	/*
	VaultsGet Get Supported Vaults

	Get all vaults with filters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVaultsGetRequest
	*/
	VaultsGet(ctx context.Context) ApiVaultsGetRequest

	// VaultsGetExecute executes the request
	//  @return []ListVaultsInner
	VaultsGetExecute(r ApiVaultsGetRequest) ([]ListVaultsInner, *http.Response, error)
}

// InfoApiService InfoApi service
type InfoApiService service

type ApiPositionsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	wallet *string
}

func (r ApiPositionsGetRequest) Wallet(wallet string) ApiPositionsGetRequest {
	r.wallet = &wallet
	return r
}

func (r ApiPositionsGetRequest) Execute() ([]ListPositionsInner, *http.Response, error) {
	return r.ApiService.PositionsGetExecute(r)
}

/*
PositionsGet Get User Positions

Get all user positions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPositionsGetRequest
*/
func (a *InfoApiService) PositionsGet(ctx context.Context) ApiPositionsGetRequest {
	return ApiPositionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListPositionsInner
func (a *InfoApiService) PositionsGetExecute(r ApiPositionsGetRequest) ([]ListPositionsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListPositionsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.PositionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wallet == nil {
		return localVarReturnValue, nil, reportError("wallet is required and must be specified")
	}

	localVarQueryParams.Add("Wallet", parameterToString(*r.wallet, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProtoconfigsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	tokenA *string
	tokenB *string
}

func (r ApiProtoconfigsGetRequest) TokenA(tokenA string) ApiProtoconfigsGetRequest {
	r.tokenA = &tokenA
	return r
}

func (r ApiProtoconfigsGetRequest) TokenB(tokenB string) ApiProtoconfigsGetRequest {
	r.tokenB = &tokenB
	return r
}

func (r ApiProtoconfigsGetRequest) Execute() ([]ListProtoConfigsInner, *http.Response, error) {
	return r.ApiService.ProtoconfigsGetExecute(r)
}

/*
ProtoconfigsGet Get Proto Configs

Get all proto configs with filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProtoconfigsGetRequest
*/
func (a *InfoApiService) ProtoconfigsGet(ctx context.Context) ApiProtoconfigsGetRequest {
	return ApiProtoconfigsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListProtoConfigsInner
func (a *InfoApiService) ProtoconfigsGetExecute(r ApiProtoconfigsGetRequest) ([]ListProtoConfigsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListProtoConfigsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.ProtoconfigsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protoconfigs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenA != nil {
		localVarQueryParams.Add("tokenA", parameterToString(*r.tokenA, ""))
	}
	if r.tokenB != nil {
		localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRootGetRequest struct {
	ctx context.Context
	ApiService InfoApi
}

func (r ApiRootGetRequest) Execute() (*PingResponse, *http.Response, error) {
	return r.ApiService.RootGetExecute(r)
}

/*
RootGet Health Check

Ping api.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRootGetRequest
*/
func (a *InfoApiService) RootGet(ctx context.Context) ApiRootGetRequest {
	return ApiRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PingResponse
func (a *InfoApiService) RootGetExecute(r ApiRootGetRequest) (*PingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.RootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwaggerJsonGetRequest struct {
	ctx context.Context
	ApiService InfoApi
}

func (r ApiSwaggerJsonGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SwaggerJsonGetExecute(r)
}

/*
SwaggerJsonGet Swagger spec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSwaggerJsonGetRequest
*/
func (a *InfoApiService) SwaggerJsonGet(ctx context.Context) ApiSwaggerJsonGetRequest {
	return ApiSwaggerJsonGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *InfoApiService) SwaggerJsonGetExecute(r ApiSwaggerJsonGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.SwaggerJsonGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swagger.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwapConfigsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	vault *string
}

func (r ApiSwapConfigsGetRequest) Vault(vault string) ApiSwapConfigsGetRequest {
	r.vault = &vault
	return r
}

func (r ApiSwapConfigsGetRequest) Execute() ([]ListSwapConfigsInner, *http.Response, error) {
	return r.ApiService.SwapConfigsGetExecute(r)
}

/*
SwapConfigsGet Get Token Swaps Configs

Get token swap configs fro triggerDCA.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSwapConfigsGetRequest
*/
func (a *InfoApiService) SwapConfigsGet(ctx context.Context) ApiSwapConfigsGetRequest {
	return ApiSwapConfigsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListSwapConfigsInner
func (a *InfoApiService) SwapConfigsGetExecute(r ApiSwapConfigsGetRequest) ([]ListSwapConfigsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListSwapConfigsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.SwapConfigsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swapConfigs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vault != nil {
		localVarQueryParams.Add("vault", parameterToString(*r.vault, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwapsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	tokenPair *string
}

func (r ApiSwapsGetRequest) TokenPair(tokenPair string) ApiSwapsGetRequest {
	r.tokenPair = &tokenPair
	return r
}

func (r ApiSwapsGetRequest) Execute() ([]ListTokenSwapsInner, *http.Response, error) {
	return r.ApiService.SwapsGetExecute(r)
}

/*
SwapsGet Get Token Swaps

Get token swaps with filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSwapsGetRequest
*/
func (a *InfoApiService) SwapsGet(ctx context.Context) ApiSwapsGetRequest {
	return ApiSwapsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListTokenSwapsInner
func (a *InfoApiService) SwapsGetExecute(r ApiSwapsGetRequest) ([]ListTokenSwapsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListTokenSwapsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.SwapsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swaps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenPair != nil {
		localVarQueryParams.Add("tokenPair", parameterToString(*r.tokenPair, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokenpairsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	tokenA *string
	tokenB *string
}

func (r ApiTokenpairsGetRequest) TokenA(tokenA string) ApiTokenpairsGetRequest {
	r.tokenA = &tokenA
	return r
}

func (r ApiTokenpairsGetRequest) TokenB(tokenB string) ApiTokenpairsGetRequest {
	r.tokenB = &tokenB
	return r
}

func (r ApiTokenpairsGetRequest) Execute() ([]ListTokenPairsInner, *http.Response, error) {
	return r.ApiService.TokenpairsGetExecute(r)
}

/*
TokenpairsGet Get Token Pairs

Get token pairs with filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTokenpairsGetRequest
*/
func (a *InfoApiService) TokenpairsGet(ctx context.Context) ApiTokenpairsGetRequest {
	return ApiTokenpairsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListTokenPairsInner
func (a *InfoApiService) TokenpairsGetExecute(r ApiTokenpairsGetRequest) ([]ListTokenPairsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListTokenPairsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.TokenpairsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tokenpairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenA != nil {
		localVarQueryParams.Add("tokenA", parameterToString(*r.tokenA, ""))
	}
	if r.tokenB != nil {
		localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTokensGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	tokenA *string
	tokenB *string
}

func (r ApiTokensGetRequest) TokenA(tokenA string) ApiTokensGetRequest {
	r.tokenA = &tokenA
	return r
}

func (r ApiTokensGetRequest) TokenB(tokenB string) ApiTokensGetRequest {
	r.tokenB = &tokenB
	return r
}

func (r ApiTokensGetRequest) Execute() ([]ListTokensInner, *http.Response, error) {
	return r.ApiService.TokensGetExecute(r)
}

/*
TokensGet Get Tokens

Get tokens with filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTokensGetRequest
*/
func (a *InfoApiService) TokensGet(ctx context.Context) ApiTokensGetRequest {
	return ApiTokensGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListTokensInner
func (a *InfoApiService) TokensGetExecute(r ApiTokensGetRequest) ([]ListTokensInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListTokensInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.TokensGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenA != nil {
		localVarQueryParams.Add("tokenA", parameterToString(*r.tokenA, ""))
	}
	if r.tokenB != nil {
		localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVaultperiodsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	vault *string
	vaultPeriod *string
	offset *int32
	limit *int32
}

func (r ApiVaultperiodsGetRequest) Vault(vault string) ApiVaultperiodsGetRequest {
	r.vault = &vault
	return r
}

func (r ApiVaultperiodsGetRequest) VaultPeriod(vaultPeriod string) ApiVaultperiodsGetRequest {
	r.vaultPeriod = &vaultPeriod
	return r
}

func (r ApiVaultperiodsGetRequest) Offset(offset int32) ApiVaultperiodsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiVaultperiodsGetRequest) Limit(limit int32) ApiVaultperiodsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiVaultperiodsGetRequest) Execute() ([]ListVaultPeriodsInner, *http.Response, error) {
	return r.ApiService.VaultperiodsGetExecute(r)
}

/*
VaultperiodsGet Get Vault Periods

Get vault periods with pagination and filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVaultperiodsGetRequest
*/
func (a *InfoApiService) VaultperiodsGet(ctx context.Context) ApiVaultperiodsGetRequest {
	return ApiVaultperiodsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListVaultPeriodsInner
func (a *InfoApiService) VaultperiodsGetExecute(r ApiVaultperiodsGetRequest) ([]ListVaultPeriodsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListVaultPeriodsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.VaultperiodsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vaultperiods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vault == nil {
		return localVarReturnValue, nil, reportError("vault is required and must be specified")
	}

	localVarQueryParams.Add("vault", parameterToString(*r.vault, ""))
	if r.vaultPeriod != nil {
		localVarQueryParams.Add("vaultPeriod", parameterToString(*r.vaultPeriod, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVaultsGetRequest struct {
	ctx context.Context
	ApiService InfoApi
	tokenA *string
	tokenB *string
	protoConfig *string
}

func (r ApiVaultsGetRequest) TokenA(tokenA string) ApiVaultsGetRequest {
	r.tokenA = &tokenA
	return r
}

func (r ApiVaultsGetRequest) TokenB(tokenB string) ApiVaultsGetRequest {
	r.tokenB = &tokenB
	return r
}

// Vault proto config public key.
func (r ApiVaultsGetRequest) ProtoConfig(protoConfig string) ApiVaultsGetRequest {
	r.protoConfig = &protoConfig
	return r
}

func (r ApiVaultsGetRequest) Execute() ([]ListVaultsInner, *http.Response, error) {
	return r.ApiService.VaultsGetExecute(r)
}

/*
VaultsGet Get Supported Vaults

Get all vaults with filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVaultsGetRequest
*/
func (a *InfoApiService) VaultsGet(ctx context.Context) ApiVaultsGetRequest {
	return ApiVaultsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListVaultsInner
func (a *InfoApiService) VaultsGetExecute(r ApiVaultsGetRequest) ([]ListVaultsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListVaultsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoApiService.VaultsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tokenA != nil {
		localVarQueryParams.Add("tokenA", parameterToString(*r.tokenA, ""))
	}
	if r.tokenB != nil {
		localVarQueryParams.Add("tokenB", parameterToString(*r.tokenB, ""))
	}
	if r.protoConfig != nil {
		localVarQueryParams.Add("protoConfig", parameterToString(*r.protoConfig, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
